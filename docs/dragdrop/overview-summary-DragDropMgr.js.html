
<html>
<head>
	<title>JavaScript Documentation - DragDropMgr.js</title>
	<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div id="header">
	<h1>JavaScript Documentation</h1>
	<h3><a href="./index.html">Drag and Drop</a></h3>

	<div class="breadcrumbs">
		
			
			
			
				<a href="./index.html">Drag and Drop</a>
				&gt;
				<strong>DragDropMgr.js</strong>
			
			
			
			
			
			
			
			
			
			
			
		
	</div>
</div>


<div id="body">
	
	
	<div class="nav">
		<div class="module resources">
			<ul class="content">
				<li><a href="overview-tree.html">Tree View</a></li>
				<li><a href="index-all.html">Element Index</a></li>
			</ul>
		</div>
		
		
			<div class="module">
				<h4><a href="./allclasses-noframe.html">Classes</a></h4>
				<ul class="content">
					
						<li>
							<a href="YAHOO.util.html">
								YAHOO.util</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DD.html">
								YAHOO.util.DD</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DDProxy.html">
								YAHOO.util.DDProxy</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DDTarget.html">
								YAHOO.util.DDTarget</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DragDrop.html">
								YAHOO.util.DragDrop</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DragDropMgr.html">
								YAHOO.util.DragDropMgr</a>
						</li>
					
				</ul>
			</div>
		
		
		
			<div class="module">
				<h4><a href="./overview-summary.html">Files</a></h4>
				<ul class="content">		
					
						<li>
							<a href="overview-summary-DD.js.html">
								DD.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DDProxy.js.html">
								DDProxy.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DDTarget.js.html">
								DDTarget.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DragDrop.js.html">
								DragDrop.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DragDropMgr.js.html">
								DragDropMgr.js</a>
						</li>
					
				</ul>
			</div>
		
	</div>
	
	<div class="main">
			
		
		
			
			   <h2>DragDropMgr.js</h2>
			
			
				
					
				
				
				
<div class="meta">
	
	
	
	
	
	
	
	
	
	
		
	
	
	
	
	
	
</div>

			
		
		
		
		
		
		
		
		
		
			<div class="section source">
				<h3><a name="source">Souce Code</a> <span class="top">[<a href="#top">top</a>]</span></h3>
				<pre class="sourceview"><span class="comment">/* Copyright (c) 2006 Yahoo! Inc. All rights reserved. */</span>
<span class="comment">
// Only load the library once.  Rewriting the manager class would orphan </span>
<span class="comment">// existing drag and drop instances.</span>
<span class="reserved">if</span> (!YAHOO.util.DragDropMgr) {

    <span class="comment">/**
     * Handles the element interaction for all DragDrop items in the 
     * window.  Generally, you will not call this class directly, but it does
     * have helper methods that could be useful in your DragDrop 
     * implementations.  This class should not be instantiated; all methods 
     * are are static.
     *
     * <span class="attrib">@constructor</span>
     */</span>
    YAHOO.util.DragDropMgr = new <span class="reserved">function</span>() {
        <span class="comment">/**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to 
         * false if you need the default behavior (not recommended)
         *
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.preventDefault = true;

        <span class="comment">/**
         * Flag to determine if we should stop the propagation of the events 
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         *
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.stopPropagation = true;

        <span class="comment">/**
         * In point mode, drag and drop interaction is defined by the 
         * location of the cursor during the drag/drop
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.POINT     = 0;

        <span class="comment">/**
         * In intersect mode, drag and drop interactio nis defined by the 
         * overlap of two or more drag and drop objects.
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.INTERSECT = 1;

        <span class="comment">/**
         * The current drag and drop mode.  Default it point mode
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.mode = <span class="reserved">this</span>.POINT;

        <span class="comment">/**
         * Lock all drag and drop functionality
         */</span>
        <span class="reserved">this</span>.lock = <span class="reserved">function</span>() { <span class="reserved">this</span>.locked = true; };

        <span class="comment">/**
         * Unlock all drag and drop functionality
         */</span>
        <span class="reserved">this</span>.unlock = <span class="reserved">function</span>() { <span class="reserved">this</span>.locked = false; };

        <span class="comment">/**
         * Is drag and drop locked?
         *
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.locked = false;

        <span class="comment">/**
         * Is drag and drop locked?
         *
         * <span class="attrib">@return</span> {boolean} True if drag and drop is locked, false otherwise.
         */</span>
        <span class="reserved">this</span>.isLocked = <span class="reserved">function</span>() { <span class="reserved">return</span> <span class="reserved">this</span>.locked; };
        <span class="comment">/**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.useCache = true;

        <span class="comment">/**
         * The number of pixels that the mouse needs to move after the 
         * mousedown before the drag is initiated.  Default=3;
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.clickPixelThresh = 3;

        <span class="comment">/**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.clickTimeThresh = 1000;
        
       <span class="comment">/**
         * Each DragDrop instance must be registered with the DragDropMgr.  
         * This is executed in ygDragDrop.init()
         *
         * <span class="attrib">@param</span> {DragDrop} oDD the DragDrop object to register
         * <span class="attrib">@param</span> {String} sGroup the name of the group this element belongs to
         */</span>
        <span class="reserved">this</span>.regDragDrop = <span class="reserved">function</span>(oDD, sGroup) {
            <span class="reserved">if</span> (!<span class="reserved">this</span>.initialized) { <span class="reserved">this</span>.init(); }
            
            <span class="reserved">if</span> (!<span class="reserved">this</span>.ids[sGroup]) {
                <span class="reserved">this</span>.ids[sGroup] = {};
            }
            <span class="reserved">this</span>.ids[sGroup][oDD.id] = oDD;
        };

        

        <span class="comment">/**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing ygDragDrop.setHandleElId()
         *
         * <span class="attrib">@param</span> {String} sDDId the DragDrop id this element is a handle for
         * <span class="attrib">@param</span> {String} sHandleId the id of the element that is the drag 
         * handle
         */</span>
        <span class="reserved">this</span>.regHandle = <span class="reserved">function</span>(sDDId, sHandleId) {
            <span class="reserved">if</span> (!<span class="reserved">this</span>.handleIds[sDDId]) {
                <span class="reserved">this</span>.handleIds[sDDId] = {};
            }
            <span class="reserved">this</span>.handleIds[sDDId][sHandleId] = sHandleId;
        };

        <span class="comment">/**
         * Utility function to determine if a given element has been 
         * registered as a drag drop item.
         *
         * <span class="attrib">@param</span> {String} id the element id to check
         * <span class="attrib">@return</span> {boolean} true if this element is a DragDrop item, 
         * false otherwise
         */</span>
        <span class="reserved">this</span>.isDragDrop = <span class="reserved">function</span>(id) {
            <span class="reserved">return</span> ( <span class="reserved">this</span>.getDDById(id) ) ? true : false;
        };

        <span class="comment">/**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         *
         * <span class="attrib">@param</span> {ygDragDrop} p_oDD the obj to get related data for
         * <span class="attrib">@param</span> {boolean} bTargetsOnly if true, only return targetable objs
         * <span class="attrib">@return</span> {ygDragDrop[]} the related instances
         */</span>
        <span class="reserved">this</span>.getRelated = <span class="reserved">function</span>(p_oDD, bTargetsOnly) {
            var oDDs = [];
            <span class="reserved">for</span> (var i in p_oDD.groups) {
                <span class="reserved">for</span> (j in <span class="reserved">this</span>.ids[i]) {
                    var dd = <span class="reserved">this</span>.ids[i][j];
                    <span class="reserved">if</span> (! <span class="reserved">this</span>.isTypeOfDD(dd)) {
                        continue;
                    }
                    <span class="reserved">if</span> (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            <span class="reserved">return</span> oDDs;
        };

        <span class="comment">/**
         * Returns true if the specified dd target is a legal target for 
         * the specifice drag obj
         *
         * <span class="attrib">@param</span> {ygDragDrop} the drag obj
         * <span class="attrib">@param</span> {ygDragDrop) the target
         * <span class="attrib">@return</span> {boolean} true if the target is a legal target for the 
         * dd obj
         */</span>
        <span class="reserved">this</span>.isLegalTarget = <span class="reserved">function</span> (oDD, oTargetDD) {
            var targets = <span class="reserved">this</span>.getRelated(oDD);
            <span class="reserved">for</span> (var i=0, len=targets.length;i&lt;len;++i) {
                <span class="reserved">if</span> (targets[i].id == oTargetDD.id) {
                    <span class="reserved">return</span> true;
                }
            }

            <span class="reserved">return</span> false;
        };

        <span class="comment">/**
         * My goal is to be able to transparently determine if an object is
         * typeof ygDragDrop, and the exact subclass of ygDragDrop.  typeof 
         * returns "object", oDD.constructor.toString() always returns
         * "ygDragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in ygDragDrop.
         *
         * <span class="attrib">@param</span> {Object} the object to evaluate
         * <span class="attrib">@return</span> {boolean} true if typeof oDD = ygDragDrop
         */</span>
        <span class="reserved">this</span>.isTypeOfDD = <span class="reserved">function</span> (oDD) {
            <span class="reserved">return</span> (oDD &amp;&amp; oDD.__ygDragDrop);
        };

        <span class="comment">/**
         * Utility function to determine if a given element has been 
         * registered as a drag drop handle for the given Drag Drop object.
         *
         * <span class="attrib">@param</span> {String} id the element id to check
         * <span class="attrib">@return</span> {boolean} true if this element is a DragDrop handle, false 
         * otherwise
         */</span>
        <span class="reserved">this</span>.isHandle = <span class="reserved">function</span>(sDDId, sHandleId) {
            <span class="reserved">return</span> ( <span class="reserved">this</span>.handleIds[sDDId] &amp;&amp; 
                            <span class="reserved">this</span>.handleIds[sDDId][sHandleId] );
        };

        <span class="comment">/**
         * Returns the DragDrop instance for a given id
         *
         * <span class="attrib">@param</span> {String} id the id of the DragDrop object
         * <span class="attrib">@return</span> {DragDrop} the drag drop object, null if it is not found
         */</span>
        <span class="reserved">this</span>.getDDById = <span class="reserved">function</span>(id) {
            <span class="reserved">for</span> (var i in <span class="reserved">this</span>.ids) {
                <span class="reserved">if</span> (<span class="reserved">this</span>.ids[i][id]) {
                    <span class="reserved">return</span> <span class="reserved">this</span>.ids[i][id];
                }
            }
            <span class="reserved">return</span> null;
        };

        
        <span class="comment">/**
         * Fired when either the drag pixel threshol or the mousedown hold 
         * time threshold has been met.
         * 
         * <span class="attrib">@param</span> x {int} the X position of the original mousedown
         * <span class="attrib">@param</span> y {int} the Y position of the original mousedown
         */</span>
        <span class="reserved">this</span>.startDrag = <span class="reserved">function</span>(x, y) {
            <span class="reserved">this</span>.logger.debug(<span class="literal">"firing drag start events"</span>);
            clearTimeout(<span class="reserved">this</span>.clickTimeout);
            <span class="reserved">if</span> (<span class="reserved">this</span>.dragCurrent) {
                <span class="reserved">this</span>.dragCurrent.b4StartDrag(x, y);
                <span class="reserved">this</span>.dragCurrent.startDrag(x, y);
            }

            <span class="comment">/**
             * <span class="attrib">@private</span>
             */</span>
            <span class="reserved">this</span>.dragThreshMet = true;
        };

        

        <span class="comment">/**
         * Utility to stop event propagation and event default, if these 
         * features are turned on.
         *
         * <span class="attrib">@param</span> {Event} e the event as returned by this.getEvent()
         */</span>
        <span class="reserved">this</span>.stopEvent = <span class="reserved">function</span>(e) {
            <span class="reserved">if</span> (<span class="reserved">this</span>.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            <span class="reserved">if</span> (<span class="reserved">this</span>.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        };

        


        <span class="comment">/**
         * Helper function for getting the best match from the list of drag 
         * and drop objects returned by the drag and drop events when we are 
         * in INTERSECT mode.  It returns either the first object that the 
         * cursor is over, or the object that has the greatest overlap with 
         * the dragged element.
         *
         * <span class="attrib">@param</span>  {ygDragDrop[]} dds The array of drag and drop objects 
         * targeted
         * <span class="attrib">@return</span> {ygDragDrop}       The best single match
         */</span>
        <span class="reserved">this</span>.getBestMatch = <span class="reserved">function</span>(dds) {
            var winner = null;
<span class="comment">            // Return null if the input is not what we expect</span>
<span class="comment">            //if (!dds || !dds.length || dds.length == 0) {</span>
<span class="comment">               // winner = null;</span>
<span class="comment">            // If there is only one item, it wins</span>
<span class="comment">            //} else if (dds.length == 1) {</span>

            var len = dds.length;

            <span class="reserved">if</span> (len == 1) {
                winner = dds[0];
            } <span class="reserved">else</span> {
<span class="comment">                // Loop through the targeted items</span>
                <span class="reserved">for</span> (var i=0; i&lt;len; ++i) {
                    var dd = dds[i];
<span class="comment">                    // If the cursor is over the object, it wins.  If the </span>
<span class="comment">                    // cursor is over multiple matches, the first one we come</span>
<span class="comment">                    // to wins.</span>
                    <span class="reserved">if</span> (dd.cursorIsOver) {
                        winner = dd;
                        break;
<span class="comment">                    // Otherwise the object with the most overlap wins</span>
                    } <span class="reserved">else</span> {
                        <span class="reserved">if</span> (!winner || 
                            winner.overlap.getArea() &lt; dd.overlap.getArea()) {
                            winner = dd;
                        }
                    }
                }
            }

            <span class="reserved">return</span> winner;
        };

        <span class="comment">/**
         * Refreshes the cache of the top-left and bottom-right points of the 
         * drag and drop objects in the specified groups
         *
         * <span class="attrib">@param</span> {Array} aGroups an associative array of groups to refresh
         */</span>
        <span class="reserved">this</span>.refreshCache = <span class="reserved">function</span>(aGroups) {
            <span class="reserved">this</span>.logger.debug(<span class="literal">"refreshing element location cache"</span>);
            <span class="reserved">for</span> (sGroup in aGroups) {
                <span class="reserved">if</span> (<span class="literal">"string"</span> != typeof sGroup) {
                    continue;
                }
                <span class="reserved">for</span> (i in <span class="reserved">this</span>.ids[sGroup]) {
                    var oDD = <span class="reserved">this</span>.ids[sGroup][i];

                    <span class="reserved">if</span> (<span class="reserved">this</span>.isTypeOfDD(oDD)) {
                        var loc = <span class="reserved">this</span>.getLocation(oDD);
                        <span class="reserved">if</span> (loc) {
                            <span class="reserved">this</span>.locationCache[oDD.id] = loc;
                        } <span class="reserved">else</span> {
                            delete <span class="reserved">this</span>.locationCache[oDD.id];
                            <span class="reserved">this</span>.logger.debug(<span class="literal">"something is wrong with the element"</span>);
<span class="comment">                            // this will unregister the drag and drop object if</span>
<span class="comment">                            // the element is not in a usable state</span>
                            oDD.unreg();
                        }
                    }
                }
            }
        };

        <span class="comment">/**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * <span class="attrib">@param</span> {HTMLElement} el the element to check
         * <span class="attrib">@return</span> {boolean} true if the element looks usable
         */</span>
        <span class="reserved">this</span>.verifyEl = <span class="reserved">function</span>(el) {
            try {
                <span class="reserved">if</span> (el) {
                    var parent = el.offsetParent;
                    <span class="reserved">if</span> (parent) {
                        <span class="reserved">return</span> true;
                    }
                }
            } catch(e) {
                <span class="reserved">this</span>.logger.debug(<span class="literal">"detected problem with an element"</span>);
            }

            <span class="reserved">return</span> false;
        };
        
        <span class="comment">/**
         * Returns the an array containing the drag and drop element's position
         * and size, including the ygDragDrop.padding configured for it
         *
         * <span class="attrib">@param</span> {ygDragDrop} oDD the drag and drop object to get the 
         * location for
         * <span class="attrib">@return</span> array containing the top left and bottom right points of the 
         * element 
         */</span>
        <span class="reserved">this</span>.getLocation = <span class="reserved">function</span>(oDD) {
            <span class="reserved">if</span> (! <span class="reserved">this</span>.isTypeOfDD(oDD)) {
                <span class="reserved">this</span>.logger.debug(oDD + <span class="literal">" is not a DD obj"</span>);
                <span class="reserved">return</span> null;
            }

            var el = oDD.getEl();

            <span class="reserved">if</span> (!<span class="reserved">this</span>.verifyEl(el)) {
                <span class="reserved">this</span>.logger.debug(oDD + <span class="literal">" element is not usable"</span>);
                <span class="reserved">return</span> null;
            }
<span class="comment">
            // this.logger.debug(oDD.id + " padding: " + oDD.padding);</span>
<span class="comment">
            // var aPos = ygPos.getPos(el);</span>
            var aPos = YAHOO.util.Dom.getXY(el);

            x1 = aPos[0];
            x2 = x1 + el.offsetWidth;

            y1 = aPos[1];
            y2 = y1 + el.offsetHeight;

            var t = y1 - oDD.padding[0];
            var r = x2 + oDD.padding[1];
            var b = y2 + oDD.padding[2];
            var l = x1 - oDD.padding[3];

            <span class="reserved">return</span> new YAHOO.util.Region( t, r, b, l );

        };

        

        <span class="comment">/**
         * Returns the actual DOM element
         *
         * <span class="attrib">@param</span> {String} id the id of the elment to get
         * <span class="attrib">@return</span> {Object} The element
         */</span>
        <span class="reserved">this</span>.getElement = <span class="reserved">function</span>(id) {
<span class="comment">            // return this.getElWrapper(id).el;</span>
            <span class="reserved">return</span> document.getElementById(id);
        };
        
        <span class="comment">/**
         * Returns the style property for the DOM element (i.e., 
         * document.getElById(id).style)
         *
         * <span class="attrib">@param</span> {String} id the id of the elment to get
         * <span class="attrib">@return</span> {Object} The style property of the element
         */</span>
        <span class="reserved">this</span>.getCss = <span class="reserved">function</span>(id) {
<span class="comment">            // return this.getElWrapper(id).css;</span>
            var css = null;
            var el = document.getElementById(id);
            <span class="reserved">if</span> (el) {
                css = el.style;
            }

            <span class="reserved">return</span> css;
        };

        <span class="comment">/**
         * Returns the X position of an html element
         * <span class="attrib">@param</span> el the element for which to get the position
         * <span class="attrib">@return</span> {int} the X coordinate
         */</span>
        <span class="reserved">this</span>.getPosX = <span class="reserved">function</span>(el) {
            <span class="reserved">return</span> YAHOO.util.Dom.getX(el);
        };

        <span class="comment">/**
         * Returns the Y position of an html element
         * <span class="attrib">@param</span> el the element for which to get the position
         * <span class="attrib">@return</span> {int} the Y coordinate
         */</span>
        <span class="reserved">this</span>.getPosY = <span class="reserved">function</span>(el) {
            <span class="reserved">return</span> YAHOO.util.Dom.getY(el); 
        };

        <span class="comment">/**
         * Swap two nodes.  In IE, we use the native method, for others we 
         * emulate the IE behavior
         *
         * <span class="attrib">@param</span> n1 the first node to swap
         * <span class="attrib">@param</span> n2 the other node to swap
         */</span>
        <span class="reserved">this</span>.swapNode = <span class="reserved">function</span>(n1, n2) {
            <span class="reserved">if</span> (n1.swapNode) {
                n1.swapNode(n2);
            } <span class="reserved">else</span> {
<span class="comment">                // the node reference order for the swap is a little tricky. </span>
                var p = n2.parentNode;
                var s = n2.nextSibling;
                n1.parentNode.replaceChild(n2, n1);
                p.insertBefore(n1,s);
            }
        };

        <span class="comment">/**
         * Returns the specified element style property
         * <span class="attrib">@param</span> {HTMLElement} el          the element
         * <span class="attrib">@param</span> {string}      styleProp   the style property
         * <span class="attrib">@return</span> {string}     The value of the style property
         * <span class="attrib">@deprecated</span>, use YAHOO.util.Dom.getStyle
         */</span>
        <span class="reserved">this</span>.getStyle = <span class="reserved">function</span>(el, styleProp) {
            <span class="reserved">return</span> YAHOO.util.Dom.getStyle(el, styleProp);
        };

        <span class="comment">/**
         * Gets the scrollTop
         *
         * <span class="attrib">@return</span> {int} the document's scrollTop
         */</span>
        <span class="reserved">this</span>.getScrollTop = <span class="reserved">function</span> () { <span class="reserved">return</span> <span class="reserved">this</span>.getScroll().top; };

        <span class="comment">/**
         * Gets the scrollLeft
         *
         * <span class="attrib">@return</span> {int} the document's scrollTop
         */</span>
        <span class="reserved">this</span>.getScrollLeft = <span class="reserved">function</span> () { <span class="reserved">return</span> <span class="reserved">this</span>.getScroll().left; };

        <span class="reserved">this</span>.moveToEl = <span class="reserved">function</span> (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            <span class="reserved">this</span>.logger.debug(<span class="literal">"moveToEl: "</span> + aCoord);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        };

        <span class="comment">/**
         * Gets the client height
         *
         * <span class="attrib">@return</span> {int} client height in px
         */</span>
        <span class="reserved">this</span>.getClientHeight = <span class="reserved">function</span>() {
            <span class="reserved">return</span> (window.innerHeight) ? window.innerHeight : 
                (document.documentElement &amp;&amp; document.documentElement.clientHeight) ?
                document.documentElement.clientHeight : document.body.offsetHeight;
        };

        <span class="comment">/**
         * Gets the client width
         *
         * <span class="attrib">@return</span> {int} client width in px
         */</span>
        <span class="reserved">this</span>.getClientWidth = <span class="reserved">function</span>() {
            <span class="reserved">return</span> (window.innerWidth) ? window.innerWidth : 
                (document.documentElement &amp;&amp; document.documentElement.clientWidth) ?
                document.documentElement.clientWidth : document.body.offsetWidth;
        };

        <span class="comment">/**
         * numeric array sort function
         */</span>
        <span class="reserved">this</span>.numericSort = <span class="reserved">function</span>(a, b) { <span class="reserved">return</span> (a - b); };

        
        <span class="comment">/**
         * Recursively searches the immediate parent and all child nodes for 
         * the handle element in order to determine wheter or not it was 
         * clicked.
         *
         * <span class="attrib">@param</span> node the html element to inspect
         */</span>
        <span class="reserved">this</span>.handleWasClicked = <span class="reserved">function</span>(node, id) {
            <span class="reserved">if</span> (<span class="reserved">this</span>.isHandle(id, node.id)) {
                <span class="reserved">this</span>.logger.debug(<span class="literal">"clicked node is a handle"</span>);
                <span class="reserved">return</span> true;
            } <span class="reserved">else</span> {
<span class="comment">                // check to see if this is a text node child of the one we want</span>
                var p = node.parentNode;
<span class="comment">                // this.logger.debug("p: " + p);</span>

                <span class="reserved">while</span> (p) {
                    <span class="reserved">if</span> (<span class="reserved">this</span>.isHandle(id, p.id)) {
                        <span class="reserved">return</span> true;
                    } <span class="reserved">else</span> {
                        <span class="reserved">this</span>.logger.debug(p.id + <span class="literal">" is not a handle"</span>);
                        p = p.parentNode;
                    }
                }
            }

            <span class="reserved">return</span> false;
        };

    } ();
<span class="comment">
    // shorter alias, save a few bytes</span>
    YAHOO.util.DDM = YAHOO.util.DragDropMgr;
    YAHOO.util.DDM._addListeners();

}

</pre>
			</div>
		
	</div>
</div>


<div id="footer">
    <hr />
    Copyright &copy; 2004 - 2006 Yahoo! Inc. All rights reserved.
</div>


</body>
</html>
